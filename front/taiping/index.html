<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>タイピング</title>
    <link rel="stylesheet" href="./style.css">
</head>

<body>
    <div class="conteiner">
        <div id="timer" class="timer" id="" timer>0</div><!-- /.timer -->
        <div class="typing-aria">
            <div id="typing-q" class="typing-q"></div><!-- /.typing-q -->
            <input type="text" class="typing-input" id="typing-input" autofocus>
        </div><!-- /.typingaria -->
    </div><!-- /.conteiner -->


    <script>
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // タイピングゲーム

        const quession = document.getElementById('typing-q');
        const inputText = document.getElementById('typing-input');

        /* APIのURL */
        const URL = "https://api.quotable.io/random";


        /**ランダムなテキストを取得*/
        async function getData() {
            try {
                const rondomData = await fetch(URL);
                if (rondomData.status === 200) {
                    const data = await rondomData.json();
                    return data.content;

                } else {
                    throw new Error('fetch失敗');
                }

            } catch (err) {
                console.error(err);
            }
        }
        /**ランダムなテキストを表示*/
        async function RondomText() {
            const textData = await getData();
            // 文章を一文字ずつ分解、spanタグで囲む
            /* splitで文字列を分解、一つ一つ配列にしてspanTextに格納*/
            const spanText = textData.split('');
            /*配列化したspanTextを繰替処理*/
            spanText.forEach((text) => {
                /* spanタグを生成 */
                const spanTag = document.createElement('span');
                /*生成したspanタグに配列に分解したテキストを一文字ずつ入れる*/
                spanTag.textContent = text;
                spanTag.setAttribute('class', 'correct');
                /*<span>テキスト一文字</span>を問題を表示するタグの子要素に一つずつ追加　*/
                /* 全てのテキストがspanタグに囲われた状態で画面に描画される*/
                quession.appendChild(spanTag);
            });
        }
        RondomText();

        /**取得したテキストと入力したテキストの比較*/
        /* inputしたテキストが入力されるたびに発火するイベント*/
        inputText.addEventListener('input', (e) => {
            /* 画面に表示されている quessiontextを取得し変数に格納。Allのため配列で格納される*/
            const quessionArray = document.querySelectorAll('span');
            /* inkputに入力された文字を取得して変数に格納※入力されるたびに取得するためinput */
            /* タグの中身ではないためvalueではなくdataでとる。eはイベントオブジェクト*/
            let answerText = e.data;
            console.log(answerText)

        });


        /* 比較の結果あっていればマーカーかテキストの色を変更する */

        /* 全てのテキストが一致したら次のテキストを表示する */

        /* */

        //////////////////////////////////////////////////////////////////////////////////////////////////
        // 非同期まとめ
        //promise＝非同期ではない。promiseを使うと非同期の処理を任意の順序に制御できる
        //promiseの中の処理は同期的に処理される。非同期処理の機能を持った関数等はpromiseに関係なくメインスレッドから外れる
        //promiseを使うと.thenを使用できる※正しくはpromiseオブジェクトにthenを使用できる
        //ただしresolve + thisを使用すると非同期的に処理が可能。なぜなら.thenのコールバックは全てマルチタスクキューに入るから
        //通常はpromiseの中に非同期的な処理を記述し非同期的な処理の完了を待つ必要がある処理を.thenやawaitで対応する
        //非同期処理がメインスレッドから外れ後続の処理が実行されるため
        //非同期処理が完了したら実行したい処理をthenのコーバックに記述書いておく
        //thenを実行するためにresoleveを非同期の処理の中に記述する
        //fetchは内部的に処理結果をresoleveまたはrejevtを返すようになっているため明示的にresolve等を記述しないでok
        //非同期処理が実行されresolveが実行されるとpromiseが成功の状態になり.thenのコールバックがマルチタスクキューに登録される
        //.thenのコールバックはメインスレッドの処理が全て完了した時点で実行される。
        //↑つまり、非同期の処理の結果を待ち、必要に応じて非同期処理結果を用いた処理が可能になる
        //非同期の処理結果はresolve()の引数に渡すことで.thenに渡すことができる

        //////////////////////////////////////////////////////////////////////////////////////////////////

        //非同期練習1：promis//////////////////////////////////////////////////////////////////////////////
        // function promise() {
        //     return new Promise((resolve, reject) => {
        //         console.log('promise関数1')
        //         //resolveが実行されpromiseが成功の状態になり.thenに登録されたコールバックがマルチタスクキューに入る
        //         //マルチタスクキューはメインスレッドが終わるまで実行されない
        //         resolve('hello');
        //         console.log('promise関数2')
        //     });

        // }
        // promise().then((res) => console.log(res));
        // //上記.thenのコールバックはマルチタスクキューに入っているため下記のlogが先に表示される
        // console.log('promise関数の後')


        //非同期練習1：async + promises//////////////////////////////////////////////////////////////////////////////

        //asyncを使用するため関数を定義
        //非同期処理にawaitつけ,次の処理が走らないようにする
        //次の処理（例えばawait data.json();の部分）にデータを引き継ぐためawaitの結果は変数に格納
        //処理の最後にreturnでnewDataを返し、プロミスオブジェクトを返す
        // const getData = async () => {
        //     const data = await fetch(URL);
        //     const newData = await data.json();
        //     console.log(newData.content)
        //     return newData;

        // }



        // new Promise((resolve, reject) => {
        //     async function test() {
        //         const data = await getData();
        //         resolve(data);
        //     }
        //     test();
        // })
        //     .then((res) => {
        //         console.log('2回目', res.content)
        //         console.log('promiseの中:promiseより後に記述した文章')
        //     });



        // console.log('promiseの外:promiseより後に記述した文章')


        //非同期練習2：promises//////////////////////////////////////////////////////////////////////////////
        // お約束を取り付けたい処理にPromise
        // new Promise((resolve, reject) => {
        //     //1秒後に実行する処理
        //     setTimeout(() => {
        //         console.log("2番目(1秒後に実行)");
        //         let num = 0;
        //         //無事処理が終わったことを伝える
        //         resolve(num);
        //     }, 1000);

        // })
        //     .then((num) => {
        //         // 処理が無事終わったことを受けとって実行される処理
        //         let newNun = num + 1;
        //         console.log("3番目", newNun);

        //         return newNun;

        //     })
        //     .then((newNun) => {
        //         // 処理が無事終わったことを受けとって実行される処理
        //         if (newNun < 2) {
        //             console.log(newNun);
        //             throw new Error('エラー発生')
        //         }
        //     })
        //     .catch((err) => {
        //         console.error(err);
        //     }
        //     )







    </script>

</body>

</html>